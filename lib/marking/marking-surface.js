// Generated by CoffeeScript 1.6.3
(function() {
  var BaseClass, CASE_SENSITIVE_ATTRIBUTES, DEV_PORT, ElementBase, FILTER_ID_PREFIX, KEYS, LOG_EVENTS, Mark, MarkingSurface, NAMESPACES, NON_ATTRIBUTE_PROPERTIES, SVG, Tool, ToolControls, ToolFocusTarget, ToolLabel, insertStyle, matchesSelector, _ref, _ref1,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  matchesSelector = (function() {
    var MATCHES_SELECTOR, MATCH_METHODS, method, _i, _len;
    MATCH_METHODS = ['mozMatchesSelector', 'msMatchesSelector', 'oMatchesSelector', 'webkitMatchesSelector', 'matchesSelector', 'matches'];
    for (_i = 0, _len = MATCH_METHODS.length; _i < _len; _i++) {
      method = MATCH_METHODS[_i];
      if (method in Element.prototype) {
        MATCHES_SELECTOR = method;
      }
    }
    return function(el, selector) {
      return typeof el[MATCHES_SELECTOR] === "function" ? el[MATCHES_SELECTOR](selector) : void 0;
    };
  })();

  insertStyle = (function() {
    var IE_HACK_ID;
    IE_HACK_ID = 'marking-surface-element-that-only-exists-to-please-ie';
    return function(id, styleContent) {
      var ieHackElement;
      document.querySelector('style, link[rel="stylesheet"]').insertAdjacentHTML('beforeBegin', "<span id=\"" + IE_HACK_ID + "\"></span>\n<style id=\"" + id + "\">" + styleContent + "</style>");
      ieHackElement = document.getElementById(IE_HACK_ID);
      ieHackElement.parentNode.removeChild(ieHackElement);
      return document.getElementById(id);
    };
  })();

  DEV_PORT = +location.port > 1023;

  LOG_EVENTS = !!~location.search.indexOf('log=1');

  if (DEV_PORT) {
    window.MARKING_SURFACE_OBJECTS = [];
  }

  BaseClass = (function() {
    function BaseClass(params) {
      var property, value;
      if (params == null) {
        params = {};
      }
      if (DEV_PORT) {
        window.MARKING_SURFACE_OBJECTS.push(this);
      }
      this._events = {};
      for (property in params) {
        value = params[property];
        this[property] = value;
      }
    }

    BaseClass.prototype.on = function(eventName, handler) {
      var _base;
      if ((_base = this._events)[eventName] == null) {
        _base[eventName] = [];
      }
      return this._events[eventName].push(handler);
    };

    BaseClass.prototype.trigger = function(eventName, args) {
      var handler, _i, _len, _ref, _ref1;
      if (args == null) {
        args = [];
      }
      if (LOG_EVENTS) {
        if (typeof console !== "undefined" && console !== null) {
          console.group((_ref = this.el) != null ? _ref : this.constructor.name, eventName, args);
        }
      }
      if (eventName in this._events) {
        _ref1 = this._events[eventName];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          handler = _ref1[_i];
          this.applyHandler(handler, args);
        }
      }
      if (LOG_EVENTS) {
        return typeof console !== "undefined" && console !== null ? console.groupEnd() : void 0;
      }
    };

    BaseClass.prototype.applyHandler = function(handler, givenArgs) {
      var context, savedArgs, _ref;
      if (givenArgs == null) {
        givenArgs = [];
      }
      context = this;
      if (handler instanceof Array) {
        _ref = handler, context = _ref[0], handler = _ref[1], savedArgs = 3 <= _ref.length ? __slice.call(_ref, 2) : [];
      }
      if (savedArgs == null) {
        savedArgs = [];
      }
      if (typeof handler === 'string') {
        handler = context[handler];
      }
      return handler.call.apply(handler, [context].concat(__slice.call(savedArgs), __slice.call(givenArgs)));
    };

    BaseClass.prototype.off = function(eventName, handler) {
      var handlerIndex, handlerList, property, _results;
      if (eventName != null) {
        if (eventName in this._events) {
          handlerList = this._events[eventName];
          if (handler != null) {
            handlerIndex = handlerList.indexOf(handler);
            return handlerList.splice(handlerIndex, 1);
          } else {
            return handlerList.splice(0);
          }
        }
      } else {
        _results = [];
        for (property in this._events) {
          _results.push(delete this._events[property]);
        }
        return _results;
      }
    };

    BaseClass.prototype.destroy = function() {
      var index;
      this.trigger('marking-surface:base:destroy');
      this.off();
      if (DEV_PORT) {
        index = window.MARKING_SURFACE_OBJECTS.indexOf(this);
        return window.MARKING_SURFACE_OBJECTS.splice(index, 1);
      }
    };

    return BaseClass;

  })();

  ElementBase = (function(_super) {
    __extends(ElementBase, _super);

    ElementBase.prototype.tag = 'div';

    ElementBase.prototype.disabled = false;

    ElementBase.prototype._startEvent = null;

    function ElementBase() {
      this._eventListeners = {};
      this._delegatedListeners = {};
      ElementBase.__super__.constructor.apply(this, arguments);
      if (this.el == null) {
        this._createEl();
      }
      this.addEvent('mousedown', this._onStart);
      this.addEvent('touchstart', this._onStart);
      if (this.disabled) {
        this.disable();
      }
    }

    ElementBase.prototype._createEl = function() {
      var classNames, tagName, _ref;
      _ref = this.tag.split('.'), tagName = _ref[0], classNames = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
      this.el = document.createElement(tagName);
      return this.el.className = classNames.join(' ');
    };

    ElementBase.prototype.attr = function(attribute, value) {
      if (arguments.length === 1) {
        this.el.getAttribute(attribute);
      } else {
        if (value != null) {
          this.el.setAttribute(attribute, value);
        } else {
          this.el.removeAttribute(attribute);
        }
      }
      if ('msMatchesSelector' in document.body) {
        this.el.style.display = 'none';
        return this.el.style.display = '';
      }
    };

    ElementBase.prototype.enable = function(e) {
      this.disabled = false;
      this.attr('disabled', null);
      return this.trigger('marking-surface:element:enable');
    };

    ElementBase.prototype.disable = function(e) {
      this.disabled = true;
      this.attr('disabled', true);
      return this.trigger('marking-surface:element:disable');
    };

    ElementBase.prototype.addEvent = function() {
      var delegate, eventName, handler, _arg, _base, _base1, _base2, _i;
      eventName = arguments[0], _arg = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), handler = arguments[_i++];
      delegate = _arg[0];
      if (!(eventName in this._eventListeners || eventName in this._delegatedListeners)) {
        this.el.addEventListener(eventName, this, false);
      }
      if (delegate != null) {
        if ((_base = this._delegatedListeners)[eventName] == null) {
          _base[eventName] = {};
        }
        if ((_base1 = this._delegatedListeners[eventName])[delegate] == null) {
          _base1[delegate] = [];
        }
        return this._delegatedListeners[eventName][delegate].push(handler);
      } else {
        if ((_base2 = this._eventListeners)[eventName] == null) {
          _base2[eventName] = [];
        }
        return this._eventListeners[eventName].push(handler);
      }
    };

    ElementBase.prototype._onStart = function(e) {
      this._startEvent = e;
      addEventListener('mousemove', this, false);
      addEventListener('mouseup', this, false);
      addEventListener('touchmove', this, false);
      addEventListener('touchend', this, false);
      addEventListener('touchcancel', this, false);
      return this.dispatchEvent('marking-surface:element:start', {
        originalEvent: e
      });
    };

    ElementBase.prototype._onMove = function(e) {
      return this.dispatchEvent('marking-surface:element:move', {
        originalEvent: e
      });
    };

    ElementBase.prototype._onRelease = function(e) {
      removeEventListener('mousemove', this, false);
      removeEventListener('mouseup', this, false);
      removeEventListener('touchmove', this, false);
      removeEventListener('touchend', this, false);
      removeEventListener('touchcancel', this, false);
      this.dispatchEvent('marking-surface:element:release', {
        originalEvent: e
      });
      return this._startEvent = null;
    };

    ElementBase.prototype.handleEvent = function(e) {
      var handler, handlers, match, moveTarget, selector, target, type, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results;
      if (!this.disabled) {
        if (e.currentTarget === window) {
          switch (e.type) {
            case 'mousemove':
            case 'touchmove':
              return this._onMove(e);
            case 'mouseup':
            case 'touchend':
            case 'touchcancel':
              return this._onRelease(e);
          }
        } else {
          type = e.type;
          if ((_ref = e.detail) != null ? _ref.originalEvent : void 0) {
            e = e.detail.originalEvent;
            moveTarget = (_ref1 = (_ref2 = this._startEvent) != null ? _ref2.target : void 0) != null ? _ref1 : (_ref3 = this._startEvent) != null ? _ref3.srcElement : void 0;
          }
          if (type in this._eventListeners) {
            _ref4 = this._eventListeners[type];
            for (_i = 0, _len = _ref4.length; _i < _len; _i++) {
              handler = _ref4[_i];
              this.applyHandler(handler, [e]);
            }
          }
          if (type in this._delegatedListeners) {
            _ref5 = this._delegatedListeners[type];
            _results = [];
            for (selector in _ref5) {
              handlers = _ref5[selector];
              match = null;
              target = (_ref6 = moveTarget != null ? moveTarget : e.target) != null ? _ref6 : e.srcElement;
              while ((target != null) && (match == null)) {
                if (matchesSelector(target, selector)) {
                  match = target;
                }
                target = target.parentNode;
              }
              if (match != null) {
                _results.push((function() {
                  var _j, _len1, _results1;
                  _results1 = [];
                  for (_j = 0, _len1 = handlers.length; _j < _len1; _j++) {
                    handler = handlers[_j];
                    _results1.push(this.applyHandler(handler, [e]));
                  }
                  return _results1;
                }).call(this));
              } else {
                _results.push(void 0);
              }
            }
            return _results;
          }
        }
      }
    };

    ElementBase.prototype.removeEvent = function() {
      var delegate, eventName, handler, handlers, index, _arg, _i;
      eventName = arguments[0], _arg = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), handler = arguments[_i++];
      delegate = _arg[0];
      handlers = delegate != null ? eventName in this._delegatedListeners ? delegate in this._delegatedListeners[eventName] ? __indexOf.call(this._delegatedListeners[eventName], handler) >= 0 ? this._delegatedListeners[eventName] : void 0 : void 0 : void 0 : eventName in this._eventListeners ? __indexOf.call(this._eventListeners[eventName], handler) >= 0 ? this._eventListeners[eventName] : void 0 : void 0;
      if (handlers != null) {
        index = handlers.indexOf(handler);
        return handlers.splice(index, 1);
      }
    };

    ElementBase.prototype.dispatchEvent = function(eventName, detail) {
      var e;
      e = document.createEvent('CustomEvent');
      e.initCustomEvent(eventName, true, true, detail);
      return this.el.dispatchEvent(e);
    };

    ElementBase.prototype.pointerOffset = function(e) {
      var left, top, x, y, _ref;
      if ('touches' in e) {
        e = e.touches[0];
      }
      _ref = this.el.getBoundingClientRect(), left = _ref.left, top = _ref.top;
      x = e.pageX - pageXOffset - left;
      y = e.pageY - pageYOffset - top;
      return {
        x: x,
        y: y
      };
    };

    ElementBase.prototype.toFront = function() {
      var _ref;
      return (_ref = this.el.parentNode) != null ? _ref.appendChild(this.el) : void 0;
    };

    ElementBase.prototype.remove = function() {
      var _ref;
      if (this.el.parentNode != null) {
        if ((_ref = this.el.parentNode) != null) {
          _ref.removeChild(this.el);
        }
        return this.trigger('marking-surface:element:remove');
      }
    };

    ElementBase.prototype.destroy = function() {
      var eventName;
      for (eventName in this._eventListeners) {
        this.el.removeEventListener(eventName, this, false);
      }
      for (eventName in this._delegatedListeners) {
        if (eventName in this._eventListeners) {
          continue;
        }
        this.el.removeEventListener(eventName, this, false);
      }
      this._eventListeners = {};
      this._delegatedListeners = {};
      ElementBase.__super__.destroy.apply(this, arguments);
      return this.remove();
    };

    return ElementBase;

  })(BaseClass);

  NAMESPACES = {
    svg: 'http://www.w3.org/2000/svg',
    xlink: 'http://www.w3.org/1999/xlink'
  };

  CASE_SENSITIVE_ATTRIBUTES = ['markerHeight', 'markerWidth', 'preserveAspectRatio', 'refX', 'refY', 'stdDeviation', 'tableValues', 'viewBox'];

  NON_ATTRIBUTE_PROPERTIES = ['textContent'];

  FILTER_ID_PREFIX = 'marking-surface-filter-';

  SVG = (function(_super) {
    __extends(SVG, _super);

    SVG.prototype.tag = 'svg';

    SVG.prototype.defaultAttrs = null;

    function SVG() {
      SVG.__super__.constructor.apply(this, arguments);
      if (this.defaultAttrs != null) {
        this.attr(this.defaultAttrs);
        this.defaultAttrs = null;
      }
    }

    SVG.prototype._createEl = function() {
      var classNames, namespace, tagName, _i, _ref, _ref1;
      _ref = this.tag.split('.'), tagName = _ref[0], classNames = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
      tagName || (tagName = 'svg');
      _ref1 = tagName.split(':'), namespace = 2 <= _ref1.length ? __slice.call(_ref1, 0, _i = _ref1.length - 1) : (_i = 0, []), tagName = _ref1[_i++];
      namespace = namespace.join(':') || 'svg';
      this.el = document.createElementNS(NAMESPACES[namespace] || null, tagName);
      return this.attr('class', classNames.join(' '));
    };

    SVG.prototype.attr = function(attribute, value) {
      var attributes, namespace, _i, _ref, _ref1, _results;
      if (typeof attribute === 'string') {
        if (!(__indexOf.call(CASE_SENSITIVE_ATTRIBUTES, attribute) >= 0 || __indexOf.call(NON_ATTRIBUTE_PROPERTIES, attribute) >= 0)) {
          attribute = (attribute.replace(/([A-Z])/g, '-$1')).toLowerCase();
        }
        _ref = attribute.split(':'), namespace = 2 <= _ref.length ? __slice.call(_ref, 0, _i = _ref.length - 1) : (_i = 0, []), attribute = _ref[_i++];
        namespace = (_ref1 = NAMESPACES[namespace.join('')]) != null ? _ref1 : null;
        if (arguments.length === 1) {
          if (__indexOf.call(NON_ATTRIBUTE_PROPERTIES, attribute) >= 0) {
            return this.el[attribute];
          } else {
            return this.el.getAttributeNS(namespace, attribute);
          }
        } else {
          if (value != null) {
            if (__indexOf.call(NON_ATTRIBUTE_PROPERTIES, attribute) >= 0) {
              return this.el[attribute] = value;
            } else {
              return this.el.setAttributeNS(namespace, attribute, value);
            }
          } else {
            return this.el.removeAttributeNS(namespace, attribute);
          }
        }
      } else {
        attributes = attribute;
        _results = [];
        for (attribute in attributes) {
          value = attributes[attribute];
          _results.push(this.attr(attribute, value));
        }
        return _results;
      }
    };

    SVG.prototype.addShape = function(tag, defaultAttrs) {
      var shape;
      shape = new SVG({
        tag: tag,
        defaultAttrs: defaultAttrs
      });
      this.on('marking-surface:base:destroy', [shape, 'destroy']);
      this.el.appendChild(shape.el);
      return shape;
    };

    SVG.prototype.filter = function(name) {
      return this.attr('filter', name != null ? "url(#" + FILTER_ID_PREFIX + name + ")" : '');
    };

    return SVG;

  })(ElementBase);
  document.body.insertAdjacentHTML('afterBegin', "<svg id=\"marking-surface-filters-container\" width=\"0\" height=\"0\" style=\"bottom: 0; position: absolute; right: 0;\">\n  <defs>\n    <filter id=\"" + FILTER_ID_PREFIX + "shadow\">\n      <feGaussianBlur stdDeviation=\"2\" in=\"SourceAlpha\" />\n      <feOffset dx=\"0.5\" dy=\"1\" />\n      <feMerge>\n        <feMergeNode />\n        <feMergeNode in=\"SourceGraphic\" />\n      </feMerge>\n    </filter>\n\n    <filter id=\"" + FILTER_ID_PREFIX + "focus\">\n      <feGaussianBlur stdDeviation=\"3\" />\n      <feMerge>\n        <feMergeNode />\n        <feMergeNode in=\"SourceGraphic\" />\n      </feMerge>\n    </filter>\n\n    <filter id=\"" + FILTER_ID_PREFIX + "invert\" color-interpolation-filters=\"sRGB\">\n      <feComponentTransfer>\n        <feFuncR type=\"table\" tableValues=\"1 0\" />\n        <feFuncG type=\"table\" tableValues=\"1 0\" />\n        <feFuncB type=\"table\" tableValues=\"1 0\" />\n      </feComponentTransfer>\n    </filter>\n  </defs>\n</svg>");

  Mark = (function(_super) {
    __extends(Mark, _super);

    function Mark() {
      _ref = Mark.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    Mark.prototype.precision = 3;

    Mark.prototype.ignore = ['disabled', 'ignore', 'precision'];

    Mark.prototype.set = function(property, value, _partial) {
      var properties, setter;
      if (_partial == null) {
        _partial = false;
      }
      if (typeof property === 'string') {
        setter = this["set " + property];
        if (setter != null) {
          value = setter.call(this, value);
        }
        this[property] = value;
      } else {
        properties = property;
        for (property in properties) {
          value = properties[property];
          this.set(property, value, true);
        }
      }
      if (!_partial) {
        this.trigger('marking-surface:mark:change');
      }
    };

    Mark.prototype.toJSON = function() {
      var parts, property, result, value;
      result = {};
      for (property in this) {
        value = this[property];
        if (property.charAt(0) === '_') {
          continue;
        }
        if (__indexOf.call(this.ignore, property) >= 0) {
          continue;
        }
        if (typeof value === 'number') {
          parts = value.toString().split('.');
          if (parts[1] != null) {
            parts[1] = parts[1].slice(0, this.precision);
            value = parseFloat(parts.join('.'));
          }
        }
        result[property] = value;
      }
      return result;
    };

    return Mark;

  })(BaseClass);

  ToolControls = (function(_super) {
    __extends(ToolControls, _super);

    ToolControls.prototype.tag = 'div.marking-surface-tool-controls';

    ToolControls.prototype.template = '';

    function ToolControls() {
      ToolControls.__super__.constructor.apply(this, arguments);
      this.el.insertAdjacentHTML('beforeEnd', this.template);
      this.tool.on('marking-surface:tool:added', [this, 'followTool']);
      this.tool.addEvent('marking-surface:tool:select', [this, 'toFront']);
      this.tool.addEvent('marking-surface:tool:select', [this, 'attr', 'data-selected', true]);
      this.tool.addEvent('marking-surface:tool:deselect', [this, 'attr', 'data-selected', null]);
      this.tool.on('marking-surface:element:remove', [this, 'remove']);
      this.tool.addEvent('marking-surface:tool:destroy', [this, 'destroy']);
      this.tool.mark.on('marking-surface:mark:change', [this, 'render']);
    }

    ToolControls.prototype.followTool = function() {
      return this.tool.markingSurface.toolControlsContainer.el.appendChild(this.el);
    };

    ToolControls.prototype.moveTo = function(_arg) {
      var height, outOfBounds, width, x, y, _ref1;
      x = _arg.x, y = _arg.y;
      _ref1 = this.tool.markingSurface.scalePixelToScreen({
        x: x,
        y: y
      }), x = _ref1.x, y = _ref1.y;
      width = this.tool.markingSurface.el.offsetWidth;
      height = this.tool.markingSurface.el.offsetHeight;
      outOfBounds = x < 0 || x > width || y < 0 || y > height;
      this.attr('data-out-of-bounds', outOfBounds || null);
      this.el.style.left = "" + x + "px";
      this.el.style.top = "" + y + "px";
      this.attr('data-horizontal-room', x < width / 2 ? 'right' : 'left');
      return this.attr('data-vertical-room', y < height / 2 ? 'down' : 'up');
    };

    ToolControls.prototype.render = function() {
      return this.attr('data-complete', this.tool.isComplete() || null);
    };

    return ToolControls;

  })(ElementBase);

  ToolControls.defaultStyle = insertStyle('marking-surface-tool-controls-default-style', '.marking-surface-tool-controls {\n  position: absolute;\n}\n\n.marking-surface-tool-controls:not([data-selected]) {\n  display: none;\n}\n\n.marking-surface-tool-controls[data-out-of-bounds] {\n  display: none;\n}');

  KEYS = {
    esc: 27,
    "delete": 8
  };

  ToolFocusTarget = (function(_super) {
    __extends(ToolFocusTarget, _super);

    ToolFocusTarget.prototype.tag = 'button.marking-surface-tool-focus-target';

    function ToolFocusTarget() {
      ToolFocusTarget.__super__.constructor.apply(this, arguments);
      this.el.type = 'button';
      this.tool.addEvent('marking-surface:tool:focus', [this.el, 'focus']);
      this.addEvent('focus', [this.tool, 'focus']);
      this.addEvent('blur', [this.tool, 'blur']);
      this.addEvent('click', [this.tool, 'select']);
      this.addEvent('keydown', 'onKeydown');
    }

    ToolFocusTarget.prototype.onKeydown = function(e) {
      var index, next, noShortcutCalled, siblingFocusTargets, _ref1;
      if (!(e.metaKey || e.ctrlKey || e.altKey)) {
        switch (e.which) {
          case KEYS["delete"]:
            siblingFocusTargets = this.el.parentNode.children;
            index = Array.prototype.indexOf.call(siblingFocusTargets, this.el);
            this.tool.destroy();
            next = siblingFocusTargets[index % siblingFocusTargets.length];
            if (next != null) {
              next.focus();
            }
            break;
          case KEYS.esc:
            if ((_ref1 = this.tool.markingSurface.selection) != null) {
              _ref1.deselect();
            }
            break;
          default:
            noShortcutCalled = true;
        }
        if (!noShortcutCalled) {
          return e.preventDefault();
        }
      }
    };

    ToolFocusTarget.prototype.followTool = function() {
      var _ref1;
      return (_ref1 = this.tool.markingSurface.toolFocusTargetsContainer) != null ? _ref1.el.appendChild(this.el) : void 0;
    };

    ToolFocusTarget.prototype.render = function() {};

    return ToolFocusTarget;

  })(ToolControls);

  ToolLabel = (function(_super) {
    __extends(ToolLabel, _super);

    function ToolLabel() {
      _ref1 = ToolLabel.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    ToolLabel.prototype.tag = 'div.marking-surface-tool-label';

    ToolLabel.prototype.setContent = function(html) {
      var _ref2;
      return (_ref2 = this.el) != null ? _ref2.innerHTML = html : void 0;
    };

    return ToolLabel;

  })(ToolControls);

  ToolLabel.defaultStyle = insertStyle('marking-surface-tool-label-default-style', '.marking-surface-tool-label {\n  background: rgba(0, 0, 0, 0.5);\n  border-radius: 3px;\n  color: white;\n  padding: 3px 10px;\n  pointer-events: none;\n  position: absolute;\n  white-space: nowrap;\n}\n\n.marking-surface-tool-label:not([data-selected]) {\n  display: none;\n}\n\n.marking-surface-tool-label[data-out-of-bounds] {\n  display: none;\n}');

  Tool = (function(_super) {
    __extends(Tool, _super);

    Tool.Mark = Mark;

    Tool.Controls = null;

    Tool.mobile = !!navigator.userAgent.match(/iP|droid/);

    Tool.prototype.tag = 'g.marking-surface-tool';

    Tool.prototype.markingSurface = null;

    Tool.prototype.movements = 0;

    Tool.prototype.focused = false;

    function Tool() {
      var controls;
      Tool.__super__.constructor.apply(this, arguments);
      if (this.mark == null) {
        this.mark = new this.constructor.Mark;
      }
      this.mark.on('marking-surface:mark:change', [this, 'render']);
      this.mark.on('marking-surface:mark:change', [this, 'dispatchEvent', 'marking-surface:mark:change', [this.mark]]);
      this.mark.on('marking-surface:base:destroy', [this, 'destroy']);
      this.focusTarget = new ToolFocusTarget({
        tool: this
      });
      this.controls = this.constructor.Controls != null ? controls = new this.constructor.Controls({
        tool: this
      }) : void 0;
      this.focusRoot = SVG.prototype.addShape.call(this, 'g.marking-surface-tool-focus-root');
      this.selectedRoot = this.focusRoot.addShape('g.marking-surface-tool-selected-root');
      this.root = this.selectedRoot.addShape('g.marking-surface-tool-root');
    }

    Tool.prototype.addShape = function() {
      var _ref2;
      return (_ref2 = this.root).addShape.apply(_ref2, arguments);
    };

    Tool.prototype.coords = function(e) {
      return this.markingSurface.screenPixelToScale(this.markingSurface.sizeRect.pointerOffset(e));
    };

    Tool.prototype._onStart = function(e) {
      e.preventDefault();
      this.select();
      return Tool.__super__._onStart.apply(this, arguments);
    };

    Tool.prototype.handleEvent = function() {
      if (!this.markingSurface.disabled) {
        return Tool.__super__.handleEvent.apply(this, arguments);
      }
    };

    Tool.prototype.onInitialStart = function(e) {
      this.select();
      return this.dispatchEvent('marking-surface:tool:initial-click', [e]);
    };

    Tool.prototype.onInitialMove = function(e) {
      return this.dispatchEvent('marking-surface:tool:initial-drag', [e]);
    };

    Tool.prototype.onInitialRelease = function(e) {
      this.movements += 1;
      return this.dispatchEvent('marking-surface:tool:initial-release', [e]);
    };

    Tool.prototype.rescale = function(scaleX, scaleY) {
      return this.render();
    };

    Tool.prototype.render = function() {
      return this.attr('data-complete', this.isComplete() || null);
    };

    Tool.prototype.isComplete = function() {
      return this.movements === 1;
    };

    Tool.prototype.focus = function() {
      if (!this.focused) {
        this.focused = true;
        this.attr('data-focused', true);
        return this.dispatchEvent('marking-surface:tool:focus', [this]);
      }
    };

    Tool.prototype.blur = function() {
      if (this.focused) {
        this.focused = false;
        this.attr('data-focused', null);
        return this.dispatchEvent('marking-surface:tool:blur', [this]);
      }
    };

    Tool.prototype.select = function() {
      if (this.markingSurface.selection !== this) {
        this.focus();
        this.toFront();
        this.attr('data-selected', true);
        return this.dispatchEvent('marking-surface:tool:select', [this]);
      }
    };

    Tool.prototype.deselect = function() {
      if (this.markingSurface.selection === this) {
        this.attr('data-selected', null);
        return this.dispatchEvent('marking-surface:tool:deselect', [this]);
      }
    };

    Tool.prototype.destroy = function() {
      this.deselect();
      this.dispatchEvent('marking-surface:tool:destroy', [this]);
      return Tool.__super__.destroy.apply(this, arguments);
    };

    return Tool;

  })(SVG);

  Tool.defaultStyle = insertStyle('marking-surface-tool-default-style', ".marking-surface-tool[data-focused] .marking-surface-tool-focus-root {\n  filter: url(#" + FILTER_ID_PREFIX + "focus);\n}\n\n.marking-surface-tool[data-selected] .marking-surface-tool-selected-root {\n  filter: url(#" + FILTER_ID_PREFIX + "shadow);\n}");

  MarkingSurface = (function(_super) {
    __extends(MarkingSurface, _super);

    MarkingSurface.prototype.tag = 'div.marking-surface';

    MarkingSurface.prototype.focusable = true;

    MarkingSurface.prototype.inputName = '';

    MarkingSurface.prototype.tool = null;

    MarkingSurface.prototype.selection = null;

    MarkingSurface.prototype.scaleX = 1;

    MarkingSurface.prototype.scaleY = 1;

    function MarkingSurface() {
      var container, input;
      this.tools = [];
      MarkingSurface.__super__.constructor.apply(this, arguments);
      this.svg = new SVG({
        tag: 'svg.marking-surface-svg'
      });
      this.on('marking-surface:base:destroy', [this.svg, 'destroy']);
      this.svg.addEvent('marking-surface:mark:change', [this, 'onChangeMark']);
      this.svg.addEvent('marking-surface:tool:select', [this, 'onSelectTool']);
      this.svg.addEvent('marking-surface:tool:deselect', [this, 'onDeselectTool']);
      this.svg.addEvent('marking-surface:tool:destroy', [this, 'onDestroyTool']);
      this.sizeRect = this.svg.addShape('rect.marking-surface-size-rect', {
        fill: 'none',
        stroke: 'transparent',
        strokeWidth: 0,
        width: '100%',
        height: '100%'
      });
      this.root = this.svg.addShape('g.marking-surface-svg-root');
      this.el.appendChild(this.svg.el);
      this.toolFocusTargetsContainer = this.focusable ? (container = new ElementBase({
        tag: 'div.marking-surface-tool-focusables-container'
      }), this.on('marking-surface:base:destroy', [container, 'destroy']), this.el.appendChild(container.el), container) : void 0;
      this.toolControlsContainer = new ElementBase({
        tag: 'div.marking-surface-tool-controls-container'
      });
      this.el.appendChild(this.toolControlsContainer.el);
      this.on('marking-surface:base:destroy', [this.toolControlsContainer, 'destroy']);
      this.input = this.inputName ? (input = new ElementBase({
        tag: 'input.marking-surface-input'
      }), this.on('marking-surface:base:destroy', [input, 'destroy']), input.el.tabIndex = -1, input.el.name = this.inputName, this.on('marking-surface:mark:change', [this, 'updateInput']), this.el.appendChild(input.el), input) : void 0;
    }

    MarkingSurface.prototype.addShape = function() {
      var _ref2;
      return (_ref2 = this.root).addShape.apply(_ref2, arguments);
    };

    MarkingSurface.prototype._onStart = function(e) {
      var tool, _ref2;
      if (e.defaultPrevented) {
        return;
      }
      if (matchesSelector(e.target, '.marking-surface-tool-controls-container *')) {
        return;
      }
      e.preventDefault();
      tool = (this.selection == null) || ((_ref2 = this.selection) != null ? _ref2.isComplete() : void 0) ? this.tool != null ? this.addTool() : void 0 : this.selection;
      if (tool != null) {
        tool.select();
        tool.onInitialStart(e);
        return MarkingSurface.__super__._onStart.apply(this, arguments);
      }
    };

    MarkingSurface.prototype._onMove = function(e) {
      var _ref2;
      MarkingSurface.__super__._onMove.apply(this, arguments);
      return (_ref2 = this.selection) != null ? _ref2.onInitialMove(e) : void 0;
    };

    MarkingSurface.prototype._onRelease = function(e) {
      var _ref2;
      MarkingSurface.__super__._onRelease.apply(this, arguments);
      return (_ref2 = this.selection) != null ? _ref2.onInitialRelease(e) : void 0;
    };

    MarkingSurface.prototype.rescale = function(x, y, width, height) {
      var scaled;
      if (x == null) {
        x = '';
      }
      if (y == null) {
        y = '';
      }
      if (width == null) {
        width = '';
      }
      if (height == null) {
        height = '';
      }
      this.svg.attr('viewBox', "" + x + " " + y + " " + width + " " + height);
      scaled = this.screenPixelToScale({
        x: 100,
        y: 100
      });
      this.scaleX = 100 / scaled.x;
      this.scaleY = 100 / scaled.y;
      return this.renderTools();
    };

    MarkingSurface.prototype.addTool = function(tool) {
      if (tool == null) {
        tool = new this.tool;
      }
      tool.markingSurface = this;
      this.tools.push(tool);
      this.root.el.appendChild(tool.el);
      tool.trigger('marking-surface:tool:added', [this]);
      tool.render();
      this.trigger('marking-surface:add-tool', [tool]);
      this.trigger('marking-surface:change');
      return tool;
    };

    MarkingSurface.prototype.onSelectTool = function(e) {
      var tool, _ref2;
      tool = e.detail[0];
      if (this.selection !== tool) {
        if ((_ref2 = this.selection) != null) {
          _ref2.deselect();
        }
        this.selection = tool;
        return this.trigger('marking-surface:select-tool', [this.selection]);
      }
    };

    MarkingSurface.prototype.onChangeMark = function(e) {
      var mark;
      mark = e.detail[0];
      return this.trigger('marking-surface:change', [mark]);
    };

    MarkingSurface.prototype.updateInput = function() {
      return this.input.el.value = this.getValue();
    };

    MarkingSurface.prototype.onDeselectTool = function(e) {
      var tool;
      tool = e.detail[0];
      if (this.selection === tool) {
        this.selection = null;
        return this.trigger('marking-surface:deselect-tool', [tool]);
      }
    };

    MarkingSurface.prototype.onDestroyTool = function(e) {
      var index, tool;
      if (typeof console !== "undefined" && console !== null) {
        if (typeof console.info === "function") {
          console.info('Destroying tool');
        }
      }
      tool = e.detail[0];
      index = this.tools.indexOf(tool);
      this.tools.splice(index, 1);
      this.trigger('marking-surface:remove-tool', [tool]);
      return this.trigger('marking-surface:change');
    };

    MarkingSurface.prototype.screenPixelToScale = function(_arg) {
      var sizeRect, viewBox, x, y;
      x = _arg.x, y = _arg.y;
      if (this.svg.el.viewBox.animVal != null) {
        viewBox = this.svg.el.viewBox.animVal;
        sizeRect = this.sizeRect.el.getBoundingClientRect();
        x += viewBox.x;
        x *= viewBox.width / sizeRect.width;
        y += viewBox.y;
        y *= viewBox.height / sizeRect.height;
      }
      return {
        x: x,
        y: y
      };
    };

    MarkingSurface.prototype.scalePixelToScreen = function(_arg) {
      var sizeRect, viewBox, x, y;
      x = _arg.x, y = _arg.y;
      if (this.svg.el.viewBox.animVal != null) {
        viewBox = this.svg.el.viewBox.animVal;
        sizeRect = this.sizeRect.el.getBoundingClientRect();
        x /= viewBox.width / sizeRect.width;
        x -= viewBox.x;
        y /= viewBox.height / sizeRect.height;
        y -= viewBox.y;
      }
      return {
        x: x,
        y: y
      };
    };

    MarkingSurface.prototype.renderTools = function() {
      var tool, _i, _len, _ref2, _results;
      _ref2 = this.tools;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        tool = _ref2[_i];
        _results.push(tool.render());
      }
      return _results;
    };

    MarkingSurface.prototype.getValue = function() {
      var tool;
      return JSON.stringify((function() {
        var _i, _len, _ref2, _results;
        _ref2 = this.tools;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          tool = _ref2[_i];
          _results.push(tool.mark);
        }
        return _results;
      }).call(this));
    };

    MarkingSurface.prototype.disable = function(e) {
      var _ref2;
      if ((_ref2 = this.selection) != null) {
        _ref2.deselect();
      }
      return MarkingSurface.__super__.disable.apply(this, arguments);
    };

    MarkingSurface.prototype.reset = function() {
      while (this.tools.length !== 0) {
        this.tools[0].destroy();
      }
      return this.trigger('marking-surface:reset');
    };

    MarkingSurface.prototype.destroy = function() {
      this.reset();
      return MarkingSurface.__super__.destroy.apply(this, arguments);
    };

    return MarkingSurface;

  })(ElementBase);

  MarkingSurface.defaultStyle = insertStyle('marking-surface-default-style', '.marking-surface {\n  display: inline-block;\n  position: relative;\n}\n\n.marking-surface-svg {\n  display: block;\n  -moz-user-select: none;\n  -ms-user-select: none;\n  -webkit-user-select: none;\n}\n\n.marking-surface-input {\n  left: 0;\n  position: absolute;\n  opacity: 0;\n  pointer-events: none;\n  top: 0;\n}\n\n.marking-surface-tool-focusables-container {\n  height: 0;\n  left: 0;\n  overflow: hidden;\n  position: absolute;\n  top: 0;\n  width: 0;\n}\n\n.marking-surface-tool-controls-container {\n  left: 0;\n  position: absolute;\n  top: 0;\n}');

  MarkingSurface.BaseClass = BaseClass;

  MarkingSurface.ElementBase = ElementBase;

  MarkingSurface.SVG = SVG;

  MarkingSurface.Mark = Mark;

  MarkingSurface.ToolFocusTarget = ToolFocusTarget;

  MarkingSurface.ToolControls = ToolControls;

  MarkingSurface.ToolLabel = ToolLabel;

  MarkingSurface.Tool = Tool;

  if (typeof window !== "undefined" && window !== null) {
    window.MarkingSurface = MarkingSurface;
  }

  if (typeof module !== "undefined" && module !== null) {
    module.exports = MarkingSurface;
  }

  if (typeof define === "function") {
    define(function() {
      return MarkingSurface;
    });
  }

}).call(this);
