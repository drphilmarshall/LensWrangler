// Generated by CoffeeScript 1.6.3
(function() {
  var AxesTool, Tool,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Tool = ((typeof window !== "undefined" && window !== null ? window.MarkingSurface : void 0) || require('marking-surface')).Tool;

  AxesTool = (function(_super) {
    var handleIndex;

    __extends(AxesTool, _super);

    AxesTool.prototype.strokeWidth = 2;

    AxesTool.prototype.radius = AxesTool.mobile ? 20 : 10;

    function AxesTool() {
      var i;
      AxesTool.__super__.constructor.apply(this, arguments);
      this.marker = this.addShape('marker', {
        id: "marking-surface-axis-cap-" + (Math.random().toString().split('.')[1]),
        refX: 0.5,
        refY: 5,
        orient: 'auto'
      });
      this.marker.addShape('rect', {
        x: 0,
        y: 0,
        width: 1,
        height: 2.5,
        fill: 'currentColor'
      });
      this.marker.addShape('rect', {
        x: 0,
        y: 7.5,
        width: 1,
        height: 2.5,
        fill: 'currentColor'
      });
      this.lines = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 2; i = ++_i) {
          _results.push(this.addShape('path.axis', {
            stroke: 'currentColor',
            markerStart: "url(#" + (this.marker.attr('id')) + ")",
            markerEnd: "url(#" + (this.marker.attr('id')) + ")"
          }));
        }
        return _results;
      }).call(this);
      this.handles = (function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i < 4; i = ++_i) {
          this.mark["p" + i] = [-2 * this.radius, -2 * this.radius];
          _results.push(this.addShape('circle.handle', {
            fill: 'transparent',
            stroke: 'currentColor',
            'data-handle-index': i
          }));
        }
        return _results;
      }).call(this);
      this.addEvent('marking-surface:element:move', '.handle', [this, this.onHandleMove]);
      this.addEvent('marking-surface:element:release', '.handle', [this, this.onHandleRelease]);
    }

    AxesTool.prototype.onInitialStart = function(e) {
      var point, points, x, y, _i, _len, _ref, _results;
      _ref = this.coords(e), x = _ref.x, y = _ref.y;
      points = this.movements === 0 ? ['p0', 'p1'] : ['p2', 'p3'];
      _results = [];
      for (_i = 0, _len = points.length; _i < _len; _i++) {
        point = points[_i];
        _results.push(this.mark.set(point, [x, y]));
      }
      return _results;
    };

    AxesTool.prototype.onInitialMove = function(e) {
      var point, x, y, _ref;
      _ref = this.coords(e), x = _ref.x, y = _ref.y;
      point = this.movements === 0 ? 'p1' : 'p3';
      return this.mark.set(point, [x, y]);
    };

    AxesTool.prototype.isComplete = function() {
      return this.movements === 2;
    };

    handleIndex = null;

    AxesTool.prototype.onHandleMove = function(e) {
      var x, y, _ref;
      if (handleIndex == null) {
        handleIndex = e.target.getAttribute('data-handle-index');
      }
      _ref = this.coords(e), x = _ref.x, y = _ref.y;
      return this.mark.set("p" + handleIndex, [x, y]);
    };

    AxesTool.prototype.onHandleRelease = function() {
      return handleIndex = null;
    };

    AxesTool.prototype.render = function() {
      var handle, i, intersection, line, point, scale, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      AxesTool.__super__.render.apply(this, arguments);
      scale = (((_ref = this.markingSurface) != null ? _ref.scaleX : void 0) + ((_ref1 = this.markingSurface) != null ? _ref1.scaleY : void 0)) / 2;
      this.marker.attr({
        markerWidth: this.radius / scale,
        markerHeight: this.radius / scale
      });
      _ref2 = this.lines;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        line = _ref2[_i];
        line.attr('strokeWidth', this.strokeWidth / scale);
      }
      _ref3 = this.handles;
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        handle = _ref3[_j];
        handle.attr({
          r: this.radius / scale,
          strokeWidth: this.strokeWidth / scale
        });
      }
      this.lines[0].attr('d', "M " + this.mark.p0 + " L " + this.mark.p1);
      this.lines[1].attr('d', "M " + this.mark.p2 + " L " + this.mark.p3);
      _ref4 = ['p0', 'p1', 'p2', 'p3'];
      for (i = _k = 0, _len2 = _ref4.length; _k < _len2; i = ++_k) {
        point = _ref4[i];
        this.handles[i].attr({
          cx: this.mark[point][0],
          cy: this.mark[point][1]
        });
      }
      intersection = this.movements < 1 ? null : this.getIntersection(this.mark.p0, this.mark.p1, this.mark.p2, this.mark.p3);
      if (intersection != null) {
        this.el.setAttribute('data-intersects', true);
      } else {
        this.el.removeAttribute('data-intersects');
      }
      if (intersection == null) {
        intersection = this.movements === 0 ? [(this.mark.p0[0] + this.mark.p1[0]) / 2, (this.mark.p0[1] + this.mark.p1[1]) / 2] : [(this.mark.p0[0] + this.mark.p1[0] + this.mark.p2[0] + this.mark.p3[0]) / 4, (this.mark.p0[1] + this.mark.p1[1] + this.mark.p2[1] + this.mark.p3[1]) / 4];
      }
      return (_ref5 = this.controls) != null ? _ref5.moveTo({
        x: intersection[0],
        y: intersection[1]
      }) : void 0;
    };

    AxesTool.prototype.getIntersection = function(p0, p1, p2, p3) {
      var grads, interX, interY, sortedX, sortedY;
      grads = [(p0[1] - p1[1]) / ((p0[0] - p1[0]) || 0.00001), (p2[1] - p3[1]) / ((p2[0] - p3[0]) || 0.00001)];
      interX = ((p2[1] - p0[1]) + (grads[0] * p0[0] - grads[1] * p2[0])) / (grads[0] - grads[1]);
      interY = grads[0] * (interX - p0[0]) + p0[1];
      sortedX = [p0[0], p1[0], p2[0], p3[0], interX].sort(function(a, b) {
        return a - b;
      });
      sortedY = [p0[1], p1[1], p2[1], p3[1], interY].sort(function(a, b) {
        return a - b;
      });
      if (sortedX[2] !== interX) {
        interX = NaN;
      }
      if (sortedY[2] !== interY) {
        interY = NaN;
      }
      if ((isNaN(interX)) || (isNaN(interY))) {
        return null;
      } else {
        return [interX, interY];
      }
    };

    return AxesTool;

  })(Tool);

  if (typeof window !== "undefined" && window !== null) {
    window.MarkingSurface.AxesTool = AxesTool;
  }

  if (typeof module !== "undefined" && module !== null) {
    module.exports = AxesTool;
  }

}).call(this);
